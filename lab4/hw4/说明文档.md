# 一、添加的内容

## 1.include/const

```
#define TIME_SLICE 1000//定义时间片
#define MAX_READERS 3//定义最多有几个读者同时读
#define BRIGHT_RED//红（阻塞）
#define BRIGHT_GREEN//绿（工作中）
#define BRIGHT_BLUE//蓝（睡眠）
```

## 2.include/global

```
EXTERN int ticks;
EXTERN int readers;//读者
EXTERN int writers;//写者
EXTERN int writing;//写中，保证写唯一
extern SEMAPHORE rw_mutex;//互斥锁
extern SEMAPHORE w_mutex;
extern SEMAPHORE r_mutex;
extern SEMAPHORE n_r_mutex;
extern SEMAPHORE queue;
```

## 3.include/proc

```
#define NR_TASKS 1
#define NR_PROCS 6
typedef struct s_sema{//信号量
	int value;
	int head;
	int tail;
	PROCESS* p_list[NR_PROCS];
}SEMAPHORE;
typedef struct s_proc {
	STACK_FRAME regs;          /* process registers saved in stack frame */

	u16 ldt_sel;               /* gdt selector giving ldt base and limit */
	DESCRIPTOR ldts[LDT_SIZE]; /* local descriptors for code and data */

        int ticks;                 /* remained ticks */
        int priority;
		int blocked;
		int sleeping;
        int issleep;

	u32 pid;                   /* process id passed in from MM */
	char p_name[16];           /* name of the process */

	int nr_tty;
}PROCESS;
#define STACK_SIZE_TESTA	0x8000//定义栈空间
#define STACK_SIZE_TESTB	0x8000
#define STACK_SIZE_TESTC	0x8000
#define STACK_SIZE_TESTD	0x8000
#define STACK_SIZE_TESTE	0x8000
#define STACK_SIZE_TESTF	0x8000
#define STACK_SIZE_TOTAL	(STACK_SIZE_TTY + \
				STACK_SIZE_TESTA + \
				STACK_SIZE_TESTB + \
				STACK_SIZE_TESTC + \
				STACK_SIZE_TESTD + \
				STACK_SIZE_TESTE + \
				STACK_SIZE_TESTF)
```

## 4.include/proto

```
//klib.asm
public void disable_int();//关中断
public void enable_int();//开中断
//klib.c
public char* itoa(char* str,int num)
//main.c
void ReporterA();
void ReaderB();
void ReaderC();
void ReaderD();
void WriterE();
void WriterF();
//系统调用——用户级
public void P(SEMAPHORE* s);
public void V(SEMAPHORE* s);
```

# 二、更改的函数及其作用

## 1.clock.c/clock_handler

clock_handler用于分配进程是否处于睡眠状态并进行调度

```
PUBLIC void clock_handler(int irq)
{
	ticks++;
	p_proc_ready->ticks--;

        for (PROCESS* p = proc_table; p < proc_table+NR_TASKS+NR_PROCS; p++){
	        if (p->sleeping > 0){
                p->sleeping--;
                if (p->sleeping == 0 && p->issleep == 1){
                    p->issleep = 2;
                }
            }

	    }

        if (k_reenter != 0) {
	        return;
	}

	if (p_proc_ready->ticks > 0) {
	        return;
	}

	schedule();

}
```

## 2.main.c/read_proc&write_proc

用于分配睡眠时间

```
PRIVATE read_proc(char proc, int slices){
    sleep_ms(slices * TIME_SLICE,0); // 读耗时slices个时间片
}

PRIVATE	write_proc(char proc, int slices){
    sleep_ms(slices * TIME_SLICE,0); // 写耗时slices个时间片
}
```

## 3.读写三个策略，共6个函数（以读写公平为例）

```
void read_gp(char proc, int slices){
	P(&queue);
    P(&n_r_mutex);
	P(&r_mutex);
	if (readers==0)
		P(&rw_mutex); // 有读者正在使用，写者不可抢占
	readers++;
	V(&r_mutex);
	V(&queue);
	read_proc(proc, slices);
	P(&r_mutex);
	readers--;
	if (readers==0)
		V(&rw_mutex); // 没有读者时，可以开始写了
	V(&r_mutex);
    V(&n_r_mutex);
}

void write_gp(char proc, int slices){
	P(&queue);
	P(&rw_mutex);
	writing = 1;
	V(&queue);
	// 写过程
	write_proc(proc, slices);
	writing = 0;
	V(&rw_mutex);
}
```

## 4.以其中一个读者进程为例

```
void ReaderB()
{
    sleep_ms(delay_time * TIME_SLICE,1);//如果是写优先，读者都睡眠一个时间，便于提前调度写者
	while(1){
		read_funcs[strategy]('B', 2);//读操作
        sleep_ms(3 * TIME_SLICE,1);//睡眠若干时间片，不睡眠注释掉即可
	}
}
```

